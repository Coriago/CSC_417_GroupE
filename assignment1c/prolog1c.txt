1a.
  A Lisp association list is a list of key and value pairs. The structure of an
  association list has a list as the root that points at the current pair and 
  the next pair. The car of the pair is the key while the cdr is the datum.

  An alist can be created by the format (key . datum) 

1b.
  the assoc funtion searches through an association list (key-value pairs)
  and returns the first pair that contains the given key.
  
  A clear example:
    (assoc 'key3 ((key1 . val1) (key2 . val2) (key3 . val3)))
    This will return (KEY3 . VAL3) because it is the first pair associated with key3.
  
  So in the given example, the function returns (R . X) because that is the first pair
  associated with r.

1c. What does the LISP function "mapcan" do? Give an example of its use.

    "mapcan" applies a function across a list of elements iteratively. "mapcan" returns
    a list of return values of the applied function. If the function expects multiple 
    parameters, a list of inputs for each argument must be supplied. 

        Examples:
        (mapcan (lambda  (x y) (list (+ x y))) '(1 2 3) '(2 3 4)) ---> (3 4 7)
        (mapcan (lambda  (x)   (list (* x x))) '(1 2 3 4 5))      ---> (1 4 9 16 25)

1d.
  To create a lisp hash table we use the function make-hash-table and can assign it to a variable as such.
  
  (defparameter *table* (make-hash-table))
  
  gethash is used to retireve a hashed value and setf is able to assign a value.
  To store a value "6" with the key "key" we do:

  (setf (gethash 'key *table*) 6)
  
  or

  (push *table* 6)

  and to retireve it we do 
  (gethash 'key *table)

1e
  sublis searches through a list, and replaces all instances of one token with another.
  
  Example:
    (sublis '((1 . 2)) '(1 1 1 4 5 1))
    This replaces all instances of 1 in the second list with 2, and returns:
    (2 2 2 4 5 2)

1h
  gensym algorithmically generates a symbol with the given argument. The symbol
  is generated by concatenating the given string followed by some integer. Every
  call to gensym increments the trailing integer, so that it can be called on the
  same string multiple times and generate a unique symbol each time.
  
  So in this example, (gensym "?") generates the symbol #:?3069
  When I call (gensym "?") a second time, the symbol is #:?3070
  When I call (gensym "HELLO"), it generates the symbol #:HELLO3071

1g
  The code in (= ?x ?x) is part of the prolog rule set and doesn't need 
  functionality like ">" or "and" because it is unified. When passed into prove, 
  prove1 is called like other prolog rules and if the predicate is an "=" it attempts to unify with the rule (= ?x ?x).
